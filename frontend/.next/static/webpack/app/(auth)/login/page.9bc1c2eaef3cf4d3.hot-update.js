"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(auth)/login/page",{

/***/ "(app-pages-browser)/./contexts/WalletContext.tsx":
/*!************************************!*\
  !*** ./contexts/WalletContext.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProvider: () => (/* binding */ WalletProvider),\n/* harmony export */   useWallet: () => (/* binding */ useWallet)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _newm_io_cardano_dapp_wallet_connector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @newm.io/cardano-dapp-wallet-connector */ \"(app-pages-browser)/./node_modules/.pnpm/@newm.io+cardano-dapp-walle_812f72260531c6cf910702782d3f3628/node_modules/@newm.io/cardano-dapp-wallet-connector/dist/index.js\");\n/* harmony import */ var _newm_io_cardano_dapp_wallet_connector__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_newm_io_cardano_dapp_wallet_connector__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ WalletProvider,useWallet auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst WalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction WalletProvider(param) {\n    let { children } = param;\n    _s();\n    const { wallet, getAddress, ...walletConnector } = (0,_newm_io_cardano_dapp_wallet_connector__WEBPACK_IMPORTED_MODULE_2__.useConnectWallet)();\n    // Extract connect and disconnect functions safely\n    const connectWalletLib = walletConnector.connectWallet;\n    const disconnectWalletLib = walletConnector.disconnectWallet;\n    const [address, setAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [balance, setBalance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [rewardAddresses, setRewardAddresses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [unusedAddresses, setUnusedAddresses] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    const [availableWallets, setAvailableWallets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [customWallet, setCustomWallet] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoadingWalletData, setIsLoadingWalletData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Check for available wallets on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WalletProvider.useEffect\": ()=>{\n            const checkAvailableWallets = {\n                \"WalletProvider.useEffect.checkAvailableWallets\": ()=>{\n                    var _window_cardano, _window_cardano1, _window_cardano2, _window_cardano3, _window_cardano4, _window_cardano5, _window_cardano6, _window_cardano7;\n                    const wallets = [];\n                    // Check for common Cardano wallets\n                    if ((_window_cardano = window.cardano) === null || _window_cardano === void 0 ? void 0 : _window_cardano.nami) wallets.push(\"nami\");\n                    if ((_window_cardano1 = window.cardano) === null || _window_cardano1 === void 0 ? void 0 : _window_cardano1.eternl) wallets.push(\"eternl\");\n                    if ((_window_cardano2 = window.cardano) === null || _window_cardano2 === void 0 ? void 0 : _window_cardano2.flint) wallets.push(\"flint\");\n                    if ((_window_cardano3 = window.cardano) === null || _window_cardano3 === void 0 ? void 0 : _window_cardano3.yoroi) wallets.push(\"yoroi\");\n                    if ((_window_cardano4 = window.cardano) === null || _window_cardano4 === void 0 ? void 0 : _window_cardano4.typhon) wallets.push(\"typhon\");\n                    if ((_window_cardano5 = window.cardano) === null || _window_cardano5 === void 0 ? void 0 : _window_cardano5.gerowallet) wallets.push(\"gerowallet\");\n                    if ((_window_cardano6 = window.cardano) === null || _window_cardano6 === void 0 ? void 0 : _window_cardano6.nufi) wallets.push(\"nufi\");\n                    if ((_window_cardano7 = window.cardano) === null || _window_cardano7 === void 0 ? void 0 : _window_cardano7.lace) wallets.push(\"lace\");\n                    setAvailableWallets(wallets);\n                }\n            }[\"WalletProvider.useEffect.checkAvailableWallets\"];\n            // Check immediately and after a short delay for wallets to load\n            checkAvailableWallets();\n            const timer = setTimeout(checkAvailableWallets, 1000);\n            return ({\n                \"WalletProvider.useEffect\": ()=>clearTimeout(timer)\n            })[\"WalletProvider.useEffect\"];\n        }\n    }[\"WalletProvider.useEffect\"], []);\n    // Use custom wallet if available, otherwise use library wallet\n    const activeWallet = customWallet || wallet;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WalletProvider.useEffect\": ()=>{\n            if (activeWallet) {\n                console.log(\"🔄 Active wallet detected, extracting data...\");\n                setIsLoadingWalletData(true);\n                // Get wallet address\n                if (customWallet) {\n                    // Handle custom wallet\n                    console.log(\"🔧 Handling custom wallet data...\");\n                    handleCustomWalletData(customWallet);\n                } else {\n                    // Handle library wallet\n                    console.log(\"📚 Handling library wallet data...\");\n                    ({\n                        \"WalletProvider.useEffect\": async ()=>{\n                            try {\n                                console.log(\"🎁 Getting reward addresses (for authentication)...\");\n                                const rewardAddresses = await activeWallet.getRewardAddresses();\n                                console.log(\"🎁 Reward addresses result:\", rewardAddresses);\n                                if (rewardAddresses && rewardAddresses.length > 0) {\n                                    setRewardAddresses(rewardAddresses[0]);\n                                    console.log(\"✅ Reward address set for authentication:\", rewardAddresses[0]);\n                                    // Use reward address as the primary address for authentication\n                                    setAddress(rewardAddresses[0]);\n                                    console.log(\"✅ Using reward address as primary address for auth\");\n                                }\n                            } catch (error) {\n                                console.error(\"❌ Error getting reward addresses:\", error);\n                            }\n                            try {\n                                console.log(\"💰 Getting balance...\");\n                                const walletBalance = activeWallet.getBalance();\n                                console.log(\"💰 Balance result:\", walletBalance);\n                                setBalance(walletBalance);\n                            } catch (error) {\n                                console.error(\"❌ Error getting balance:\", error);\n                            }\n                            try {\n                                console.log(\"📭 Getting unused addresses...\");\n                                const unusedAddresses = await activeWallet.getUnusedAddresses();\n                                console.log(\"📭 Unused addresses result:\", unusedAddresses);\n                                setUnusedAddresses(unusedAddresses[0]);\n                            } catch (error) {\n                                console.error(\"❌ Error getting unused addresses:\", error);\n                            }\n                            // Only try to get regular address if reward address failed\n                            if (!rewardAddresses || rewardAddresses.length === 0) {\n                                console.log(\"⚠️ No reward address found, trying regular address methods...\");\n                                try {\n                                    console.log(\"📍 Trying getUsedAddresses as fallback...\");\n                                    const usedAddresses = await activeWallet.getUsedAddresses();\n                                    console.log(\"📍 Used addresses:\", usedAddresses);\n                                    if (usedAddresses && usedAddresses.length > 0) {\n                                        console.log(\"✅ Setting address from getUsedAddresses:\", usedAddresses[0]);\n                                        setAddress(usedAddresses[0]);\n                                    }\n                                } catch (error) {\n                                    console.error(\"❌ getUsedAddresses failed:\", error);\n                                }\n                                if (!address) {\n                                    try {\n                                        console.log(\"📍 Trying getChangeAddress as final fallback...\");\n                                        const changeAddress = await activeWallet.getChangeAddress();\n                                        console.log(\"📍 Change address:\", changeAddress);\n                                        if (changeAddress) {\n                                            console.log(\"✅ Setting address from getChangeAddress:\", changeAddress);\n                                            setAddress(changeAddress);\n                                        }\n                                    } catch (error) {\n                                        console.error(\"❌ getChangeAddress failed:\", error);\n                                    }\n                                }\n                            }\n                            setIsLoadingWalletData(false);\n                        }\n                    })[\"WalletProvider.useEffect\"]();\n                }\n            } else {\n                // Reset state when wallet disconnects\n                console.log(\"❌ No active wallet, resetting state...\");\n                setAddress(undefined);\n                setBalance(undefined);\n                setRewardAddresses(undefined);\n                setUnusedAddresses(undefined);\n                setIsLoadingWalletData(false);\n            }\n        }\n    }[\"WalletProvider.useEffect\"], [\n        activeWallet,\n        customWallet\n    ]);\n    const handleCustomWalletData = async (walletApi)=>{\n        try {\n            console.log(\"🔍 Extracting wallet data from custom wallet API...\");\n            // Get payment addresses first (priority for authentication)\n            let walletAddress = null;\n            try {\n                console.log(\"📍 Getting used addresses (payment addresses for authentication)...\");\n                const usedAddresses = await walletApi.getUsedAddresses();\n                console.log(\"📍 Used addresses:\", usedAddresses);\n                if (usedAddresses && usedAddresses.length > 0) {\n                    walletAddress = usedAddresses[0];\n                    console.log(\"✅ Using payment address for authentication:\", walletAddress);\n                }\n            } catch (error) {\n                console.error(\"❌ Error getting used addresses:\", error);\n            }\n            // Only try reward addresses if payment addresses failed\n            if (!walletAddress) {\n                console.log(\"⚠️ No payment address found, trying reward addresses...\");\n                try {\n                    console.log(\"🎁 Getting reward addresses...\");\n                    const rewardAddresses = await walletApi.getRewardAddresses();\n                    console.log(\"🎁 Reward addresses:\", rewardAddresses);\n                    if (rewardAddresses && rewardAddresses.length > 0) {\n                        setRewardAddresses(rewardAddresses[0]);\n                        walletAddress = rewardAddresses[0];\n                        console.log(\"✅ Using reward address as fallback:\", walletAddress);\n                    }\n                } catch (error) {\n                    console.log(\"⚠️ getRewardAddresses failed:\", error);\n                    try {\n                        console.log(\"📍 Trying getChangeAddress...\");\n                        const changeAddress = await walletApi.getChangeAddress();\n                        console.log(\"📍 Change address:\", changeAddress);\n                        walletAddress = changeAddress;\n                    } catch (error2) {\n                        console.log(\"⚠️ getChangeAddress failed:\", error2);\n                    }\n                }\n            }\n            if (walletAddress) {\n                console.log(\"✅ Final wallet address for authentication:\", walletAddress);\n                setAddress(walletAddress);\n            } else {\n                console.error(\"❌ Could not extract any wallet address\");\n            }\n            // Get balance\n            try {\n                console.log(\"💰 Getting wallet balance...\");\n                const balance = await walletApi.getBalance();\n                console.log(\"💰 Balance:\", balance);\n                setBalance(balance);\n            } catch (error) {\n                console.error(\"❌ Error getting balance:\", error);\n            }\n            // Get unused addresses\n            try {\n                console.log(\"📭 Getting unused addresses...\");\n                const unusedAddresses = await walletApi.getUnusedAddresses();\n                console.log(\"📭 Unused addresses:\", unusedAddresses);\n                if (unusedAddresses && unusedAddresses.length > 0) {\n                    setUnusedAddresses(unusedAddresses[0]);\n                }\n            } catch (error) {\n                console.error(\"❌ Error getting unused addresses:\", error);\n            }\n            console.log(\"✅ Custom wallet data extraction completed\");\n        } catch (error) {\n            console.error(\"❌ Error handling custom wallet data:\", error);\n        } finally{\n            setIsLoadingWalletData(false);\n        }\n    };\n    const handleConnectWallet = async (walletName, walletApi)=>{\n        try {\n            console.log(\"\\uD83D\\uDD17 Connecting to \".concat(walletName, \"...\"));\n            if (walletApi) {\n                // Custom wallet connection\n                console.log(\"🔧 Setting custom wallet...\");\n                setCustomWallet(walletApi);\n                console.log(\"✅ Custom wallet \".concat(walletName, \" connected successfully\"));\n            } else {\n                // Library wallet connection\n                console.log(\"📚 Using library wallet connection...\");\n                await connectWalletLib(walletName);\n            }\n        } catch (error) {\n            console.error(\"❌ Error connecting to \".concat(walletName, \":\"), error);\n            throw error;\n        }\n    };\n    const handleDisconnectWallet = ()=>{\n        console.log(\"🔌 Disconnecting wallet...\");\n        // Clear custom wallet first\n        if (customWallet) {\n            setCustomWallet(null);\n        }\n        // Try to disconnect library wallet safely\n        try {\n            if (disconnectWalletLib && typeof disconnectWalletLib === \"function\") {\n                disconnectWalletLib();\n            }\n        } catch (error) {\n            console.warn(\"⚠️ Library wallet disconnect failed:\", error);\n        }\n        // Always reset all state regardless of library disconnect success\n        setAddress(undefined);\n        setBalance(undefined);\n        setRewardAddresses(undefined);\n        setUnusedAddresses(undefined);\n        setIsLoadingWalletData(false);\n        console.log(\"✅ Wallet state cleared\");\n    };\n    const value = {\n        wallet: activeWallet,\n        address,\n        balance,\n        rewardAddresses,\n        unusedAddresses,\n        isConnected: !!activeWallet,\n        availableWallets,\n        isLoadingWalletData,\n        connectWallet: handleConnectWallet,\n        disconnectWallet: handleDisconnectWallet\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(WalletContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Nexus\\\\legionX\\\\frontend\\\\contexts\\\\WalletContext.tsx\",\n        lineNumber: 307,\n        columnNumber: 10\n    }, this);\n}\n_s(WalletProvider, \"4L1zLr2Lufr8MRLwp/COnSDSB60=\", false, function() {\n    return [\n        _newm_io_cardano_dapp_wallet_connector__WEBPACK_IMPORTED_MODULE_2__.useConnectWallet\n    ];\n});\n_c = WalletProvider;\nfunction useWallet() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(WalletContext);\n    if (!context) {\n        throw new Error(\"useWallet must be used within a WalletProvider\");\n    }\n    return context;\n}\n_s1(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL1dhbGxldENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNzRjtBQUNPO0FBZTdGLE1BQU1LLDhCQUFnQkgsb0RBQWFBLENBQWdDSTtBQUU1RCxTQUFTQyxlQUFlLEtBQXFDO1FBQXJDLEVBQUVDLFFBQVEsRUFBMkIsR0FBckM7O0lBQzdCLE1BQU0sRUFDSkMsTUFBTSxFQUNOQyxVQUFVLEVBQ1YsR0FBR0MsaUJBQ0osR0FBR1Asd0ZBQWdCQTtJQUVwQixrREFBa0Q7SUFDbEQsTUFBTVEsbUJBQW1CLGdCQUF5QkMsYUFBYTtJQUMvRCxNQUFNQyxzQkFBc0IsZ0JBQXlCQyxnQkFBZ0I7SUFFckUsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdqQiwrQ0FBUUE7SUFDdEMsTUFBTSxDQUFDa0IsU0FBU0MsV0FBVyxHQUFHbkIsK0NBQVFBO0lBQ3RDLE1BQU0sQ0FBQ29CLGlCQUFpQkMsbUJBQW1CLEdBQUdyQiwrQ0FBUUE7SUFDdEQsTUFBTSxDQUFDc0IsaUJBQWlCQyxtQkFBbUIsR0FBR3ZCLCtDQUFRQTtJQUN0RCxNQUFNLENBQUN3QixrQkFBa0JDLG9CQUFvQixHQUFHekIsK0NBQVFBLENBQVcsRUFBRTtJQUNyRSxNQUFNLENBQUMwQixjQUFjQyxnQkFBZ0IsR0FBRzNCLCtDQUFRQSxDQUFNO0lBQ3RELE1BQU0sQ0FBQzRCLHFCQUFxQkMsdUJBQXVCLEdBQUc3QiwrQ0FBUUEsQ0FBQztJQUUvRCx1Q0FBdUM7SUFDdkNDLGdEQUFTQTtvQ0FBQztZQUNSLE1BQU02QjtrRUFBd0I7d0JBSXhCQyxpQkFDQUEsa0JBQ0FBLGtCQUNBQSxrQkFDQUEsa0JBQ0FBLGtCQUNBQSxrQkFDQUE7b0JBVkosTUFBTUMsVUFBVSxFQUFFO29CQUVsQixtQ0FBbUM7b0JBQ25DLEtBQUlELGtCQUFBQSxPQUFPRSxPQUFPLGNBQWRGLHNDQUFBQSxnQkFBZ0JHLElBQUksRUFBRUYsUUFBUUcsSUFBSSxDQUFDO29CQUN2QyxLQUFJSixtQkFBQUEsT0FBT0UsT0FBTyxjQUFkRix1Q0FBQUEsaUJBQWdCSyxNQUFNLEVBQUVKLFFBQVFHLElBQUksQ0FBQztvQkFDekMsS0FBSUosbUJBQUFBLE9BQU9FLE9BQU8sY0FBZEYsdUNBQUFBLGlCQUFnQk0sS0FBSyxFQUFFTCxRQUFRRyxJQUFJLENBQUM7b0JBQ3hDLEtBQUlKLG1CQUFBQSxPQUFPRSxPQUFPLGNBQWRGLHVDQUFBQSxpQkFBZ0JPLEtBQUssRUFBRU4sUUFBUUcsSUFBSSxDQUFDO29CQUN4QyxLQUFJSixtQkFBQUEsT0FBT0UsT0FBTyxjQUFkRix1Q0FBQUEsaUJBQWdCUSxNQUFNLEVBQUVQLFFBQVFHLElBQUksQ0FBQztvQkFDekMsS0FBSUosbUJBQUFBLE9BQU9FLE9BQU8sY0FBZEYsdUNBQUFBLGlCQUFnQlMsVUFBVSxFQUFFUixRQUFRRyxJQUFJLENBQUM7b0JBQzdDLEtBQUlKLG1CQUFBQSxPQUFPRSxPQUFPLGNBQWRGLHVDQUFBQSxpQkFBZ0JVLElBQUksRUFBRVQsUUFBUUcsSUFBSSxDQUFDO29CQUN2QyxLQUFJSixtQkFBQUEsT0FBT0UsT0FBTyxjQUFkRix1Q0FBQUEsaUJBQWdCVyxJQUFJLEVBQUVWLFFBQVFHLElBQUksQ0FBQztvQkFFdkNWLG9CQUFvQk87Z0JBQ3RCOztZQUVBLGdFQUFnRTtZQUNoRUY7WUFDQSxNQUFNYSxRQUFRQyxXQUFXZCx1QkFBdUI7WUFFaEQ7NENBQU8sSUFBTWUsYUFBYUY7O1FBQzVCO21DQUFHLEVBQUU7SUFFTCwrREFBK0Q7SUFDL0QsTUFBTUcsZUFBZXBCLGdCQUFnQmpCO0lBRXJDUixnREFBU0E7b0NBQUM7WUFDUixJQUFJNkMsY0FBYztnQkFDaEJDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWm5CLHVCQUF1QjtnQkFFdkIscUJBQXFCO2dCQUNyQixJQUFJSCxjQUFjO29CQUNoQix1QkFBdUI7b0JBQ3ZCcUIsUUFBUUMsR0FBRyxDQUFDO29CQUNaQyx1QkFBdUJ2QjtnQkFDekIsT0FBTztvQkFDTCx3QkFBd0I7b0JBQ3hCcUIsUUFBUUMsR0FBRyxDQUFDO29CQUdYO29EQUFDOzRCQUNBLElBQUk7Z0NBQ0ZELFFBQVFDLEdBQUcsQ0FBQztnQ0FDWixNQUFNNUIsa0JBQWtCLE1BQU0wQixhQUFhSSxrQkFBa0I7Z0NBQzdESCxRQUFRQyxHQUFHLENBQUMsK0JBQStCNUI7Z0NBRTNDLElBQUlBLG1CQUFtQkEsZ0JBQWdCK0IsTUFBTSxHQUFHLEdBQUc7b0NBQ2pEOUIsbUJBQW1CRCxlQUFlLENBQUMsRUFBRTtvQ0FDckMyQixRQUFRQyxHQUFHLENBQUMsNENBQTRDNUIsZUFBZSxDQUFDLEVBQUU7b0NBRTFFLCtEQUErRDtvQ0FDL0RILFdBQVdHLGVBQWUsQ0FBQyxFQUFFO29DQUM3QjJCLFFBQVFDLEdBQUcsQ0FBQztnQ0FDZDs0QkFDRixFQUFFLE9BQU9JLE9BQU87Z0NBQ2RMLFFBQVFLLEtBQUssQ0FBQyxxQ0FBcUNBOzRCQUNyRDs0QkFFQSxJQUFJO2dDQUNGTCxRQUFRQyxHQUFHLENBQUM7Z0NBQ1osTUFBTUssZ0JBQWdCUCxhQUFhUSxVQUFVO2dDQUM3Q1AsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQks7Z0NBQ2xDbEMsV0FBV2tDOzRCQUNiLEVBQUUsT0FBT0QsT0FBTztnQ0FDZEwsUUFBUUssS0FBSyxDQUFDLDRCQUE0QkE7NEJBQzVDOzRCQUVBLElBQUk7Z0NBQ0ZMLFFBQVFDLEdBQUcsQ0FBQztnQ0FDWixNQUFNMUIsa0JBQWtCLE1BQU13QixhQUFhUyxrQkFBa0I7Z0NBQzdEUixRQUFRQyxHQUFHLENBQUMsK0JBQStCMUI7Z0NBQzNDQyxtQkFBbUJELGVBQWUsQ0FBQyxFQUFFOzRCQUN2QyxFQUFFLE9BQU84QixPQUFPO2dDQUNkTCxRQUFRSyxLQUFLLENBQUMscUNBQXFDQTs0QkFDckQ7NEJBRUEsMkRBQTJEOzRCQUMzRCxJQUFJLENBQUNoQyxtQkFBbUJBLGdCQUFnQitCLE1BQU0sS0FBSyxHQUFHO2dDQUNwREosUUFBUUMsR0FBRyxDQUFDO2dDQUVaLElBQUk7b0NBQ0ZELFFBQVFDLEdBQUcsQ0FBQztvQ0FDWixNQUFNUSxnQkFBZ0IsTUFBTVYsYUFBYVcsZ0JBQWdCO29DQUN6RFYsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQlE7b0NBQ2xDLElBQUlBLGlCQUFpQkEsY0FBY0wsTUFBTSxHQUFHLEdBQUc7d0NBQzdDSixRQUFRQyxHQUFHLENBQUMsNENBQTRDUSxhQUFhLENBQUMsRUFBRTt3Q0FDeEV2QyxXQUFXdUMsYUFBYSxDQUFDLEVBQUU7b0NBQzdCO2dDQUNGLEVBQUUsT0FBT0osT0FBTztvQ0FDZEwsUUFBUUssS0FBSyxDQUFDLDhCQUE4QkE7Z0NBQzlDO2dDQUVBLElBQUksQ0FBQ3BDLFNBQVM7b0NBQ1osSUFBSTt3Q0FDRitCLFFBQVFDLEdBQUcsQ0FBQzt3Q0FDWixNQUFNVSxnQkFBZ0IsTUFBTVosYUFBYWEsZ0JBQWdCO3dDQUN6RFosUUFBUUMsR0FBRyxDQUFDLHNCQUFzQlU7d0NBQ2xDLElBQUlBLGVBQWU7NENBQ2pCWCxRQUFRQyxHQUFHLENBQUMsNENBQTRDVTs0Q0FDeER6QyxXQUFXeUM7d0NBQ2I7b0NBQ0YsRUFBRSxPQUFPTixPQUFPO3dDQUNkTCxRQUFRSyxLQUFLLENBQUMsOEJBQThCQTtvQ0FDOUM7Z0NBQ0Y7NEJBQ0Y7NEJBRUF2Qix1QkFBdUI7d0JBQ3pCOztnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsc0NBQXNDO2dCQUN0Q2tCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWi9CLFdBQVdYO2dCQUNYYSxXQUFXYjtnQkFDWGUsbUJBQW1CZjtnQkFDbkJpQixtQkFBbUJqQjtnQkFDbkJ1Qix1QkFBdUI7WUFDekI7UUFDRjttQ0FBRztRQUFDaUI7UUFBY3BCO0tBQWE7SUFFL0IsTUFBTXVCLHlCQUF5QixPQUFPVztRQUNwQyxJQUFJO1lBQ0ZiLFFBQVFDLEdBQUcsQ0FBQztZQUVaLDREQUE0RDtZQUM1RCxJQUFJYSxnQkFBZ0I7WUFFcEIsSUFBSTtnQkFDRmQsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE1BQU1RLGdCQUFnQixNQUFNSSxVQUFVSCxnQkFBZ0I7Z0JBQ3REVixRQUFRQyxHQUFHLENBQUMsc0JBQXNCUTtnQkFFbEMsSUFBSUEsaUJBQWlCQSxjQUFjTCxNQUFNLEdBQUcsR0FBRztvQkFDN0NVLGdCQUFnQkwsYUFBYSxDQUFDLEVBQUU7b0JBQ2hDVCxRQUFRQyxHQUFHLENBQUMsK0NBQStDYTtnQkFDN0Q7WUFDRixFQUFFLE9BQU9ULE9BQU87Z0JBQ2RMLFFBQVFLLEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ25EO1lBRUEsd0RBQXdEO1lBQ3hELElBQUksQ0FBQ1MsZUFBZTtnQkFDbEJkLFFBQVFDLEdBQUcsQ0FBQztnQkFFWixJQUFJO29CQUNGRCxRQUFRQyxHQUFHLENBQUM7b0JBQ1osTUFBTTVCLGtCQUFrQixNQUFNd0MsVUFBVVYsa0JBQWtCO29CQUMxREgsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QjVCO29CQUVwQyxJQUFJQSxtQkFBbUJBLGdCQUFnQitCLE1BQU0sR0FBRyxHQUFHO3dCQUNqRDlCLG1CQUFtQkQsZUFBZSxDQUFDLEVBQUU7d0JBQ3JDeUMsZ0JBQWdCekMsZUFBZSxDQUFDLEVBQUU7d0JBQ2xDMkIsUUFBUUMsR0FBRyxDQUFDLHVDQUF1Q2E7b0JBQ3JEO2dCQUNGLEVBQUUsT0FBT1QsT0FBTztvQkFDZEwsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQ0k7b0JBQzdDLElBQUk7d0JBQ0ZMLFFBQVFDLEdBQUcsQ0FBQzt3QkFDWixNQUFNVSxnQkFBZ0IsTUFBTUUsVUFBVUQsZ0JBQWdCO3dCQUN0RFosUUFBUUMsR0FBRyxDQUFDLHNCQUFzQlU7d0JBQ2xDRyxnQkFBZ0JIO29CQUNsQixFQUFFLE9BQU9JLFFBQVE7d0JBQ2ZmLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JjO29CQUM3QztnQkFDRjtZQUNGO1lBRUEsSUFBSUQsZUFBZTtnQkFDakJkLFFBQVFDLEdBQUcsQ0FBQyw4Q0FBOENhO2dCQUMxRDVDLFdBQVc0QztZQUNiLE9BQU87Z0JBQ0xkLFFBQVFLLEtBQUssQ0FBQztZQUNoQjtZQUVBLGNBQWM7WUFDZCxJQUFJO2dCQUNGTCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTTlCLFVBQVUsTUFBTTBDLFVBQVVOLFVBQVU7Z0JBQzFDUCxRQUFRQyxHQUFHLENBQUMsZUFBZTlCO2dCQUMzQkMsV0FBV0Q7WUFDYixFQUFFLE9BQU9rQyxPQUFPO2dCQUNkTCxRQUFRSyxLQUFLLENBQUMsNEJBQTRCQTtZQUM1QztZQUVBLHVCQUF1QjtZQUN2QixJQUFJO2dCQUNGTCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osTUFBTTFCLGtCQUFrQixNQUFNc0MsVUFBVUwsa0JBQWtCO2dCQUMxRFIsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QjFCO2dCQUNwQyxJQUFJQSxtQkFBbUJBLGdCQUFnQjZCLE1BQU0sR0FBRyxHQUFHO29CQUNqRDVCLG1CQUFtQkQsZUFBZSxDQUFDLEVBQUU7Z0JBQ3ZDO1lBQ0YsRUFBRSxPQUFPOEIsT0FBTztnQkFDZEwsUUFBUUssS0FBSyxDQUFDLHFDQUFxQ0E7WUFDckQ7WUFFQUwsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsRUFBRSxPQUFPSSxPQUFPO1lBQ2RMLFFBQVFLLEtBQUssQ0FBQyx3Q0FBd0NBO1FBQ3hELFNBQVU7WUFDUnZCLHVCQUF1QjtRQUN6QjtJQUNGO0lBRUEsTUFBTWtDLHNCQUFzQixPQUFPQyxZQUFvQko7UUFDckQsSUFBSTtZQUNGYixRQUFRQyxHQUFHLENBQUMsOEJBQStCLE9BQVhnQixZQUFXO1lBRTNDLElBQUlKLFdBQVc7Z0JBQ2IsMkJBQTJCO2dCQUMzQmIsUUFBUUMsR0FBRyxDQUFDO2dCQUNackIsZ0JBQWdCaUM7Z0JBQ2hCYixRQUFRQyxHQUFHLENBQUMsbUJBQThCLE9BQVhnQixZQUFXO1lBQzVDLE9BQU87Z0JBQ0wsNEJBQTRCO2dCQUM1QmpCLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixNQUFNcEMsaUJBQWlCb0Q7WUFDekI7UUFDRixFQUFFLE9BQU9aLE9BQU87WUFDZEwsUUFBUUssS0FBSyxDQUFDLHlCQUFvQyxPQUFYWSxZQUFXLE1BQUlaO1lBQ3RELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1hLHlCQUF5QjtRQUM3QmxCLFFBQVFDLEdBQUcsQ0FBQztRQUVaLDRCQUE0QjtRQUM1QixJQUFJdEIsY0FBYztZQUNoQkMsZ0JBQWdCO1FBQ2xCO1FBRUEsMENBQTBDO1FBQzFDLElBQUk7WUFDRixJQUFJYix1QkFBdUIsT0FBT0Esd0JBQXdCLFlBQVk7Z0JBQ3BFQTtZQUNGO1FBQ0YsRUFBRSxPQUFPc0MsT0FBTztZQUNkTCxRQUFRbUIsSUFBSSxDQUFDLHdDQUF3Q2Q7UUFDdkQ7UUFFQSxrRUFBa0U7UUFDbEVuQyxXQUFXWDtRQUNYYSxXQUFXYjtRQUNYZSxtQkFBbUJmO1FBQ25CaUIsbUJBQW1CakI7UUFDbkJ1Qix1QkFBdUI7UUFFdkJrQixRQUFRQyxHQUFHLENBQUM7SUFDZDtJQUVBLE1BQU1tQixRQUFRO1FBQ1oxRCxRQUFRcUM7UUFDUjlCO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0E4QyxhQUFhLENBQUMsQ0FBQ3RCO1FBQ2Z0QjtRQUNBSTtRQUNBZixlQUFla0Q7UUFDZmhELGtCQUFrQmtEO0lBQ3BCO0lBRUEscUJBQU8sOERBQUM1RCxjQUFjZ0UsUUFBUTtRQUFDRixPQUFPQTtrQkFBUTNEOzs7Ozs7QUFDaEQ7R0FoU2dCRDs7UUFLVkgsb0ZBQWdCQTs7O0tBTE5HO0FBa1NULFNBQVMrRDs7SUFDZCxNQUFNQyxVQUFVcEUsaURBQVVBLENBQUNFO0lBQzNCLElBQUksQ0FBQ2tFLFNBQVM7UUFDWixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFDQSxPQUFPRDtBQUNUO0lBTmdCRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOZXh1c1xcbGVnaW9uWFxcZnJvbnRlbmRcXGNvbnRleHRzXFxXYWxsZXRDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB0eXBlIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiXHJcbmltcG9ydCB7IHVzZUNvbm5lY3RXYWxsZXQsIHR5cGUgRW5hYmxlZFdhbGxldCB9IGZyb20gXCJAbmV3bS5pby9jYXJkYW5vLWRhcHAtd2FsbGV0LWNvbm5lY3RvclwiXHJcblxyXG50eXBlIFdhbGxldENvbnRleHRUeXBlID0ge1xyXG4gIHdhbGxldDogRW5hYmxlZFdhbGxldCB8IG51bGxcclxuICBhZGRyZXNzOiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICBiYWxhbmNlOiBhbnlcclxuICByZXdhcmRBZGRyZXNzZXM6IGFueVtdIHwgdW5kZWZpbmVkXHJcbiAgdW51c2VkQWRkcmVzc2VzOiBhbnlbXSB8IHVuZGVmaW5lZFxyXG4gIGlzQ29ubmVjdGVkOiBib29sZWFuXHJcbiAgYXZhaWxhYmxlV2FsbGV0czogc3RyaW5nW11cclxuICBpc0xvYWRpbmdXYWxsZXREYXRhOiBib29sZWFuXHJcbiAgY29ubmVjdFdhbGxldDogKHdhbGxldE5hbWU6IHN0cmluZywgd2FsbGV0QXBpPzogYW55KSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgZGlzY29ubmVjdFdhbGxldDogKCkgPT4gdm9pZFxyXG59XHJcblxyXG5jb25zdCBXYWxsZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxXYWxsZXRDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFdhbGxldFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcclxuICBjb25zdCB7XHJcbiAgICB3YWxsZXQsXHJcbiAgICBnZXRBZGRyZXNzLFxyXG4gICAgLi4ud2FsbGV0Q29ubmVjdG9yXHJcbiAgfSA9IHVzZUNvbm5lY3RXYWxsZXQoKVxyXG4gIFxyXG4gIC8vIEV4dHJhY3QgY29ubmVjdCBhbmQgZGlzY29ubmVjdCBmdW5jdGlvbnMgc2FmZWx5XHJcbiAgY29uc3QgY29ubmVjdFdhbGxldExpYiA9ICh3YWxsZXRDb25uZWN0b3IgYXMgYW55KS5jb25uZWN0V2FsbGV0XHJcbiAgY29uc3QgZGlzY29ubmVjdFdhbGxldExpYiA9ICh3YWxsZXRDb25uZWN0b3IgYXMgYW55KS5kaXNjb25uZWN0V2FsbGV0XHJcbiAgXHJcbiAgY29uc3QgW2FkZHJlc3MsIHNldEFkZHJlc3NdID0gdXNlU3RhdGU8c3RyaW5nPigpXHJcbiAgY29uc3QgW2JhbGFuY2UsIHNldEJhbGFuY2VdID0gdXNlU3RhdGU8YW55PigpXHJcbiAgY29uc3QgW3Jld2FyZEFkZHJlc3Nlcywgc2V0UmV3YXJkQWRkcmVzc2VzXSA9IHVzZVN0YXRlPGFueT4oKVxyXG4gIGNvbnN0IFt1bnVzZWRBZGRyZXNzZXMsIHNldFVudXNlZEFkZHJlc3Nlc10gPSB1c2VTdGF0ZTxhbnk+KClcclxuICBjb25zdCBbYXZhaWxhYmxlV2FsbGV0cywgc2V0QXZhaWxhYmxlV2FsbGV0c10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pXHJcbiAgY29uc3QgW2N1c3RvbVdhbGxldCwgc2V0Q3VzdG9tV2FsbGV0XSA9IHVzZVN0YXRlPGFueT4obnVsbClcclxuICBjb25zdCBbaXNMb2FkaW5nV2FsbGV0RGF0YSwgc2V0SXNMb2FkaW5nV2FsbGV0RGF0YV0gPSB1c2VTdGF0ZShmYWxzZSlcclxuXHJcbiAgLy8gQ2hlY2sgZm9yIGF2YWlsYWJsZSB3YWxsZXRzIG9uIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNoZWNrQXZhaWxhYmxlV2FsbGV0cyA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgd2FsbGV0cyA9IFtdXHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgY29tbW9uIENhcmRhbm8gd2FsbGV0c1xyXG4gICAgICBpZiAod2luZG93LmNhcmRhbm8/Lm5hbWkpIHdhbGxldHMucHVzaChcIm5hbWlcIilcclxuICAgICAgaWYgKHdpbmRvdy5jYXJkYW5vPy5ldGVybmwpIHdhbGxldHMucHVzaChcImV0ZXJubFwiKVxyXG4gICAgICBpZiAod2luZG93LmNhcmRhbm8/LmZsaW50KSB3YWxsZXRzLnB1c2goXCJmbGludFwiKVxyXG4gICAgICBpZiAod2luZG93LmNhcmRhbm8/Lnlvcm9pKSB3YWxsZXRzLnB1c2goXCJ5b3JvaVwiKVxyXG4gICAgICBpZiAod2luZG93LmNhcmRhbm8/LnR5cGhvbikgd2FsbGV0cy5wdXNoKFwidHlwaG9uXCIpXHJcbiAgICAgIGlmICh3aW5kb3cuY2FyZGFubz8uZ2Vyb3dhbGxldCkgd2FsbGV0cy5wdXNoKFwiZ2Vyb3dhbGxldFwiKVxyXG4gICAgICBpZiAod2luZG93LmNhcmRhbm8/Lm51ZmkpIHdhbGxldHMucHVzaChcIm51ZmlcIilcclxuICAgICAgaWYgKHdpbmRvdy5jYXJkYW5vPy5sYWNlKSB3YWxsZXRzLnB1c2goXCJsYWNlXCIpXHJcblxyXG4gICAgICBzZXRBdmFpbGFibGVXYWxsZXRzKHdhbGxldHMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaW1tZWRpYXRlbHkgYW5kIGFmdGVyIGEgc2hvcnQgZGVsYXkgZm9yIHdhbGxldHMgdG8gbG9hZFxyXG4gICAgY2hlY2tBdmFpbGFibGVXYWxsZXRzKClcclxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChjaGVja0F2YWlsYWJsZVdhbGxldHMsIDEwMDApXHJcblxyXG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lcilcclxuICB9LCBbXSlcclxuXHJcbiAgLy8gVXNlIGN1c3RvbSB3YWxsZXQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdXNlIGxpYnJhcnkgd2FsbGV0XHJcbiAgY29uc3QgYWN0aXZlV2FsbGV0ID0gY3VzdG9tV2FsbGV0IHx8IHdhbGxldFxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGFjdGl2ZVdhbGxldCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflIQgQWN0aXZlIHdhbGxldCBkZXRlY3RlZCwgZXh0cmFjdGluZyBkYXRhLi4uXCIpXHJcbiAgICAgIHNldElzTG9hZGluZ1dhbGxldERhdGEodHJ1ZSlcclxuXHJcbiAgICAgIC8vIEdldCB3YWxsZXQgYWRkcmVzc1xyXG4gICAgICBpZiAoY3VzdG9tV2FsbGV0KSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIGN1c3RvbSB3YWxsZXRcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCflKcgSGFuZGxpbmcgY3VzdG9tIHdhbGxldCBkYXRhLi4uXCIpXHJcbiAgICAgICAgaGFuZGxlQ3VzdG9tV2FsbGV0RGF0YShjdXN0b21XYWxsZXQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSGFuZGxlIGxpYnJhcnkgd2FsbGV0XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OaIEhhbmRsaW5nIGxpYnJhcnkgd2FsbGV0IGRhdGEuLi5cIilcclxuXHJcbiAgICAgICAgLy8gR2V0IHJld2FyZCBhZGRyZXNzZXMgZmlyc3QgKHByaW9yaXR5IGZvciBhdXRoZW50aWNhdGlvbilcclxuICAgICAgICA7KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+OgSBHZXR0aW5nIHJld2FyZCBhZGRyZXNzZXMgKGZvciBhdXRoZW50aWNhdGlvbikuLi5cIilcclxuICAgICAgICAgICAgY29uc3QgcmV3YXJkQWRkcmVzc2VzID0gYXdhaXQgYWN0aXZlV2FsbGV0LmdldFJld2FyZEFkZHJlc3NlcygpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+OgSBSZXdhcmQgYWRkcmVzc2VzIHJlc3VsdDpcIiwgcmV3YXJkQWRkcmVzc2VzKVxyXG5cclxuICAgICAgICAgICAgaWYgKHJld2FyZEFkZHJlc3NlcyAmJiByZXdhcmRBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIHNldFJld2FyZEFkZHJlc3NlcyhyZXdhcmRBZGRyZXNzZXNbMF0pXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgUmV3YXJkIGFkZHJlc3Mgc2V0IGZvciBhdXRoZW50aWNhdGlvbjpcIiwgcmV3YXJkQWRkcmVzc2VzWzBdKVxyXG5cclxuICAgICAgICAgICAgICAvLyBVc2UgcmV3YXJkIGFkZHJlc3MgYXMgdGhlIHByaW1hcnkgYWRkcmVzcyBmb3IgYXV0aGVudGljYXRpb25cclxuICAgICAgICAgICAgICBzZXRBZGRyZXNzKHJld2FyZEFkZHJlc3Nlc1swXSlcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBVc2luZyByZXdhcmQgYWRkcmVzcyBhcyBwcmltYXJ5IGFkZHJlc3MgZm9yIGF1dGhcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBnZXR0aW5nIHJld2FyZCBhZGRyZXNzZXM6XCIsIGVycm9yKVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+SsCBHZXR0aW5nIGJhbGFuY2UuLi5cIilcclxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0QmFsYW5jZSA9IGFjdGl2ZVdhbGxldC5nZXRCYWxhbmNlKClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5KwIEJhbGFuY2UgcmVzdWx0OlwiLCB3YWxsZXRCYWxhbmNlKVxyXG4gICAgICAgICAgICBzZXRCYWxhbmNlKHdhbGxldEJhbGFuY2UpXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGdldHRpbmcgYmFsYW5jZTpcIiwgZXJyb3IpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OtIEdldHRpbmcgdW51c2VkIGFkZHJlc3Nlcy4uLlwiKVxyXG4gICAgICAgICAgICBjb25zdCB1bnVzZWRBZGRyZXNzZXMgPSBhd2FpdCBhY3RpdmVXYWxsZXQuZ2V0VW51c2VkQWRkcmVzc2VzKClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5OtIFVudXNlZCBhZGRyZXNzZXMgcmVzdWx0OlwiLCB1bnVzZWRBZGRyZXNzZXMpXHJcbiAgICAgICAgICAgIHNldFVudXNlZEFkZHJlc3Nlcyh1bnVzZWRBZGRyZXNzZXNbMF0pXHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGdldHRpbmcgdW51c2VkIGFkZHJlc3NlczpcIiwgZXJyb3IpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gT25seSB0cnkgdG8gZ2V0IHJlZ3VsYXIgYWRkcmVzcyBpZiByZXdhcmQgYWRkcmVzcyBmYWlsZWRcclxuICAgICAgICAgIGlmICghcmV3YXJkQWRkcmVzc2VzIHx8IHJld2FyZEFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLimqDvuI8gTm8gcmV3YXJkIGFkZHJlc3MgZm91bmQsIHRyeWluZyByZWd1bGFyIGFkZHJlc3MgbWV0aG9kcy4uLlwiKVxyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gVHJ5aW5nIGdldFVzZWRBZGRyZXNzZXMgYXMgZmFsbGJhY2suLi5cIilcclxuICAgICAgICAgICAgICBjb25zdCB1c2VkQWRkcmVzc2VzID0gYXdhaXQgYWN0aXZlV2FsbGV0LmdldFVzZWRBZGRyZXNzZXMoKVxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjSBVc2VkIGFkZHJlc3NlczpcIiwgdXNlZEFkZHJlc3NlcylcclxuICAgICAgICAgICAgICBpZiAodXNlZEFkZHJlc3NlcyAmJiB1c2VkQWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFNldHRpbmcgYWRkcmVzcyBmcm9tIGdldFVzZWRBZGRyZXNzZXM6XCIsIHVzZWRBZGRyZXNzZXNbMF0pXHJcbiAgICAgICAgICAgICAgICBzZXRBZGRyZXNzKHVzZWRBZGRyZXNzZXNbMF0pXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgZ2V0VXNlZEFkZHJlc3NlcyBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5ONIFRyeWluZyBnZXRDaGFuZ2VBZGRyZXNzIGFzIGZpbmFsIGZhbGxiYWNrLi4uXCIpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VBZGRyZXNzID0gYXdhaXQgYWN0aXZlV2FsbGV0LmdldENoYW5nZUFkZHJlc3MoKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5ONIENoYW5nZSBhZGRyZXNzOlwiLCBjaGFuZ2VBZGRyZXNzKVxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgU2V0dGluZyBhZGRyZXNzIGZyb20gZ2V0Q2hhbmdlQWRkcmVzczpcIiwgY2hhbmdlQWRkcmVzcylcclxuICAgICAgICAgICAgICAgICAgc2V0QWRkcmVzcyhjaGFuZ2VBZGRyZXNzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIGdldENoYW5nZUFkZHJlc3MgZmFpbGVkOlwiLCBlcnJvcilcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzZXRJc0xvYWRpbmdXYWxsZXREYXRhKGZhbHNlKVxyXG4gICAgICAgIH0pKClcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUmVzZXQgc3RhdGUgd2hlbiB3YWxsZXQgZGlzY29ubmVjdHNcclxuICAgICAgY29uc29sZS5sb2coXCLinYwgTm8gYWN0aXZlIHdhbGxldCwgcmVzZXR0aW5nIHN0YXRlLi4uXCIpXHJcbiAgICAgIHNldEFkZHJlc3ModW5kZWZpbmVkKVxyXG4gICAgICBzZXRCYWxhbmNlKHVuZGVmaW5lZClcclxuICAgICAgc2V0UmV3YXJkQWRkcmVzc2VzKHVuZGVmaW5lZClcclxuICAgICAgc2V0VW51c2VkQWRkcmVzc2VzKHVuZGVmaW5lZClcclxuICAgICAgc2V0SXNMb2FkaW5nV2FsbGV0RGF0YShmYWxzZSlcclxuICAgIH1cclxuICB9LCBbYWN0aXZlV2FsbGV0LCBjdXN0b21XYWxsZXRdKVxyXG5cclxuICBjb25zdCBoYW5kbGVDdXN0b21XYWxsZXREYXRhID0gYXN5bmMgKHdhbGxldEFwaTogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcIvCflI0gRXh0cmFjdGluZyB3YWxsZXQgZGF0YSBmcm9tIGN1c3RvbSB3YWxsZXQgQVBJLi4uXCIpXHJcblxyXG4gICAgICAvLyBHZXQgcGF5bWVudCBhZGRyZXNzZXMgZmlyc3QgKHByaW9yaXR5IGZvciBhdXRoZW50aWNhdGlvbilcclxuICAgICAgbGV0IHdhbGxldEFkZHJlc3MgPSBudWxsXHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjSBHZXR0aW5nIHVzZWQgYWRkcmVzc2VzIChwYXltZW50IGFkZHJlc3NlcyBmb3IgYXV0aGVudGljYXRpb24pLi4uXCIpXHJcbiAgICAgICAgY29uc3QgdXNlZEFkZHJlc3NlcyA9IGF3YWl0IHdhbGxldEFwaS5nZXRVc2VkQWRkcmVzc2VzKClcclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk40gVXNlZCBhZGRyZXNzZXM6XCIsIHVzZWRBZGRyZXNzZXMpXHJcblxyXG4gICAgICAgIGlmICh1c2VkQWRkcmVzc2VzICYmIHVzZWRBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgd2FsbGV0QWRkcmVzcyA9IHVzZWRBZGRyZXNzZXNbMF1cclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIFVzaW5nIHBheW1lbnQgYWRkcmVzcyBmb3IgYXV0aGVudGljYXRpb246XCIsIHdhbGxldEFkZHJlc3MpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgZ2V0dGluZyB1c2VkIGFkZHJlc3NlczpcIiwgZXJyb3IpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9ubHkgdHJ5IHJld2FyZCBhZGRyZXNzZXMgaWYgcGF5bWVudCBhZGRyZXNzZXMgZmFpbGVkXHJcbiAgICAgIGlmICghd2FsbGV0QWRkcmVzcykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pqg77iPIE5vIHBheW1lbnQgYWRkcmVzcyBmb3VuZCwgdHJ5aW5nIHJld2FyZCBhZGRyZXNzZXMuLi5cIilcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+OgSBHZXR0aW5nIHJld2FyZCBhZGRyZXNzZXMuLi5cIilcclxuICAgICAgICAgIGNvbnN0IHJld2FyZEFkZHJlc3NlcyA9IGF3YWl0IHdhbGxldEFwaS5nZXRSZXdhcmRBZGRyZXNzZXMoKVxyXG4gICAgICAgICAgY29uc29sZS5sb2coXCLwn46BIFJld2FyZCBhZGRyZXNzZXM6XCIsIHJld2FyZEFkZHJlc3NlcylcclxuXHJcbiAgICAgICAgICBpZiAocmV3YXJkQWRkcmVzc2VzICYmIHJld2FyZEFkZHJlc3Nlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHNldFJld2FyZEFkZHJlc3NlcyhyZXdhcmRBZGRyZXNzZXNbMF0pXHJcbiAgICAgICAgICAgIHdhbGxldEFkZHJlc3MgPSByZXdhcmRBZGRyZXNzZXNbMF1cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgVXNpbmcgcmV3YXJkIGFkZHJlc3MgYXMgZmFsbGJhY2s6XCIsIHdhbGxldEFkZHJlc3MpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pqg77iPIGdldFJld2FyZEFkZHJlc3NlcyBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5ONIFRyeWluZyBnZXRDaGFuZ2VBZGRyZXNzLi4uXCIpXHJcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZUFkZHJlc3MgPSBhd2FpdCB3YWxsZXRBcGkuZ2V0Q2hhbmdlQWRkcmVzcygpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi8J+TjSBDaGFuZ2UgYWRkcmVzczpcIiwgY2hhbmdlQWRkcmVzcylcclxuICAgICAgICAgICAgd2FsbGV0QWRkcmVzcyA9IGNoYW5nZUFkZHJlc3NcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyBnZXRDaGFuZ2VBZGRyZXNzIGZhaWxlZDpcIiwgZXJyb3IyKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHdhbGxldEFkZHJlc3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBGaW5hbCB3YWxsZXQgYWRkcmVzcyBmb3IgYXV0aGVudGljYXRpb246XCIsIHdhbGxldEFkZHJlc3MpXHJcbiAgICAgICAgc2V0QWRkcmVzcyh3YWxsZXRBZGRyZXNzKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgQ291bGQgbm90IGV4dHJhY3QgYW55IHdhbGxldCBhZGRyZXNzXCIpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCBiYWxhbmNlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5KwIEdldHRpbmcgd2FsbGV0IGJhbGFuY2UuLi5cIilcclxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgd2FsbGV0QXBpLmdldEJhbGFuY2UoKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+SsCBCYWxhbmNlOlwiLCBiYWxhbmNlKVxyXG4gICAgICAgIHNldEJhbGFuY2UoYmFsYW5jZSlcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIGdldHRpbmcgYmFsYW5jZTpcIiwgZXJyb3IpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCB1bnVzZWQgYWRkcmVzc2VzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OtIEdldHRpbmcgdW51c2VkIGFkZHJlc3Nlcy4uLlwiKVxyXG4gICAgICAgIGNvbnN0IHVudXNlZEFkZHJlc3NlcyA9IGF3YWl0IHdhbGxldEFwaS5nZXRVbnVzZWRBZGRyZXNzZXMoKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+TrSBVbnVzZWQgYWRkcmVzc2VzOlwiLCB1bnVzZWRBZGRyZXNzZXMpXHJcbiAgICAgICAgaWYgKHVudXNlZEFkZHJlc3NlcyAmJiB1bnVzZWRBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgc2V0VW51c2VkQWRkcmVzc2VzKHVudXNlZEFkZHJlc3Nlc1swXSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBFcnJvciBnZXR0aW5nIHVudXNlZCBhZGRyZXNzZXM6XCIsIGVycm9yKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIuKchSBDdXN0b20gd2FsbGV0IGRhdGEgZXh0cmFjdGlvbiBjb21wbGV0ZWRcIilcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgRXJyb3IgaGFuZGxpbmcgY3VzdG9tIHdhbGxldCBkYXRhOlwiLCBlcnJvcilcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldElzTG9hZGluZ1dhbGxldERhdGEoZmFsc2UpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVDb25uZWN0V2FsbGV0ID0gYXN5bmMgKHdhbGxldE5hbWU6IHN0cmluZywgd2FsbGV0QXBpPzogYW55KSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UlyBDb25uZWN0aW5nIHRvICR7d2FsbGV0TmFtZX0uLi5gKVxyXG5cclxuICAgICAgaWYgKHdhbGxldEFwaSkge1xyXG4gICAgICAgIC8vIEN1c3RvbSB3YWxsZXQgY29ubmVjdGlvblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UpyBTZXR0aW5nIGN1c3RvbSB3YWxsZXQuLi5cIilcclxuICAgICAgICBzZXRDdXN0b21XYWxsZXQod2FsbGV0QXBpKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgQ3VzdG9tIHdhbGxldCAke3dhbGxldE5hbWV9IGNvbm5lY3RlZCBzdWNjZXNzZnVsbHlgKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIExpYnJhcnkgd2FsbGV0IGNvbm5lY3Rpb25cclxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk5ogVXNpbmcgbGlicmFyeSB3YWxsZXQgY29ubmVjdGlvbi4uLlwiKVxyXG4gICAgICAgIGF3YWl0IGNvbm5lY3RXYWxsZXRMaWIod2FsbGV0TmFtZSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIGNvbm5lY3RpbmcgdG8gJHt3YWxsZXROYW1lfTpgLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGhhbmRsZURpc2Nvbm5lY3RXYWxsZXQgPSAoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIvCflIwgRGlzY29ubmVjdGluZyB3YWxsZXQuLi5cIilcclxuXHJcbiAgICAvLyBDbGVhciBjdXN0b20gd2FsbGV0IGZpcnN0XHJcbiAgICBpZiAoY3VzdG9tV2FsbGV0KSB7XHJcbiAgICAgIHNldEN1c3RvbVdhbGxldChudWxsKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBkaXNjb25uZWN0IGxpYnJhcnkgd2FsbGV0IHNhZmVseVxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKGRpc2Nvbm5lY3RXYWxsZXRMaWIgJiYgdHlwZW9mIGRpc2Nvbm5lY3RXYWxsZXRMaWIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGRpc2Nvbm5lY3RXYWxsZXRMaWIoKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTGlicmFyeSB3YWxsZXQgZGlzY29ubmVjdCBmYWlsZWQ6XCIsIGVycm9yKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsd2F5cyByZXNldCBhbGwgc3RhdGUgcmVnYXJkbGVzcyBvZiBsaWJyYXJ5IGRpc2Nvbm5lY3Qgc3VjY2Vzc1xyXG4gICAgc2V0QWRkcmVzcyh1bmRlZmluZWQpXHJcbiAgICBzZXRCYWxhbmNlKHVuZGVmaW5lZClcclxuICAgIHNldFJld2FyZEFkZHJlc3Nlcyh1bmRlZmluZWQpXHJcbiAgICBzZXRVbnVzZWRBZGRyZXNzZXModW5kZWZpbmVkKVxyXG4gICAgc2V0SXNMb2FkaW5nV2FsbGV0RGF0YShmYWxzZSlcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIuKchSBXYWxsZXQgc3RhdGUgY2xlYXJlZFwiKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdmFsdWUgPSB7XHJcbiAgICB3YWxsZXQ6IGFjdGl2ZVdhbGxldCxcclxuICAgIGFkZHJlc3MsXHJcbiAgICBiYWxhbmNlLFxyXG4gICAgcmV3YXJkQWRkcmVzc2VzLFxyXG4gICAgdW51c2VkQWRkcmVzc2VzLFxyXG4gICAgaXNDb25uZWN0ZWQ6ICEhYWN0aXZlV2FsbGV0LFxyXG4gICAgYXZhaWxhYmxlV2FsbGV0cyxcclxuICAgIGlzTG9hZGluZ1dhbGxldERhdGEsXHJcbiAgICBjb25uZWN0V2FsbGV0OiBoYW5kbGVDb25uZWN0V2FsbGV0LFxyXG4gICAgZGlzY29ubmVjdFdhbGxldDogaGFuZGxlRGlzY29ubmVjdFdhbGxldCxcclxuICB9XHJcblxyXG4gIHJldHVybiA8V2FsbGV0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dmFsdWV9PntjaGlsZHJlbn08L1dhbGxldENvbnRleHQuUHJvdmlkZXI+XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VXYWxsZXQoKSB7XHJcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoV2FsbGV0Q29udGV4dClcclxuICBpZiAoIWNvbnRleHQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVdhbGxldCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgV2FsbGV0UHJvdmlkZXJcIilcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHRcclxufVxyXG5cclxuLy8gQWRkIHR5cGUgZGVjbGFyYXRpb25zIGZvciB3aW5kb3cuY2FyZGFub1xyXG5kZWNsYXJlIGdsb2JhbCB7XHJcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XHJcbiAgICBjYXJkYW5vPzoge1xyXG4gICAgICBuYW1pPzogYW55XHJcbiAgICAgIGV0ZXJubD86IGFueVxyXG4gICAgICBmbGludD86IGFueVxyXG4gICAgICB5b3JvaT86IGFueVxyXG4gICAgICB0eXBob24/OiBhbnlcclxuICAgICAgZ2Vyb3dhbGxldD86IGFueVxyXG4gICAgICBudWZpPzogYW55XHJcbiAgICAgIGxhY2U/OiBhbnlcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VDb25uZWN0V2FsbGV0IiwiV2FsbGV0Q29udGV4dCIsInVuZGVmaW5lZCIsIldhbGxldFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ3YWxsZXQiLCJnZXRBZGRyZXNzIiwid2FsbGV0Q29ubmVjdG9yIiwiY29ubmVjdFdhbGxldExpYiIsImNvbm5lY3RXYWxsZXQiLCJkaXNjb25uZWN0V2FsbGV0TGliIiwiZGlzY29ubmVjdFdhbGxldCIsImFkZHJlc3MiLCJzZXRBZGRyZXNzIiwiYmFsYW5jZSIsInNldEJhbGFuY2UiLCJyZXdhcmRBZGRyZXNzZXMiLCJzZXRSZXdhcmRBZGRyZXNzZXMiLCJ1bnVzZWRBZGRyZXNzZXMiLCJzZXRVbnVzZWRBZGRyZXNzZXMiLCJhdmFpbGFibGVXYWxsZXRzIiwic2V0QXZhaWxhYmxlV2FsbGV0cyIsImN1c3RvbVdhbGxldCIsInNldEN1c3RvbVdhbGxldCIsImlzTG9hZGluZ1dhbGxldERhdGEiLCJzZXRJc0xvYWRpbmdXYWxsZXREYXRhIiwiY2hlY2tBdmFpbGFibGVXYWxsZXRzIiwid2luZG93Iiwid2FsbGV0cyIsImNhcmRhbm8iLCJuYW1pIiwicHVzaCIsImV0ZXJubCIsImZsaW50IiwieW9yb2kiLCJ0eXBob24iLCJnZXJvd2FsbGV0IiwibnVmaSIsImxhY2UiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJhY3RpdmVXYWxsZXQiLCJjb25zb2xlIiwibG9nIiwiaGFuZGxlQ3VzdG9tV2FsbGV0RGF0YSIsImdldFJld2FyZEFkZHJlc3NlcyIsImxlbmd0aCIsImVycm9yIiwid2FsbGV0QmFsYW5jZSIsImdldEJhbGFuY2UiLCJnZXRVbnVzZWRBZGRyZXNzZXMiLCJ1c2VkQWRkcmVzc2VzIiwiZ2V0VXNlZEFkZHJlc3NlcyIsImNoYW5nZUFkZHJlc3MiLCJnZXRDaGFuZ2VBZGRyZXNzIiwid2FsbGV0QXBpIiwid2FsbGV0QWRkcmVzcyIsImVycm9yMiIsImhhbmRsZUNvbm5lY3RXYWxsZXQiLCJ3YWxsZXROYW1lIiwiaGFuZGxlRGlzY29ubmVjdFdhbGxldCIsIndhcm4iLCJ2YWx1ZSIsImlzQ29ubmVjdGVkIiwiUHJvdmlkZXIiLCJ1c2VXYWxsZXQiLCJjb250ZXh0IiwiRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/WalletContext.tsx\n"));

/***/ })

});